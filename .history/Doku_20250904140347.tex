
\documentclass[12pt,a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}     % Für Umlaute
\usepackage[T1]{fontenc}        % Saubere Schriftkodierung
\usepackage{lmodern}            % Bessere Schriftarten
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{graphicx}           % Für Bilder
\usepackage{plantuml}
\usepackage{hyperref}           % Für klickbare Links
\usepackage[letterpaper, top=2cm, bottom=2cm, left=2cm, right=2cm, marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{enumitem}

\title{Test Interface für HAL Tests auf dem Target}
\author{Konrad Wöhrle}
\date{\today}

%==================================================================
\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Einleitung}
\subsection{Motivation, Zielsetzung und Fokus}

Das Projekt wurde im Rahmen einer studentischen Tätigkeit durchgeführt.
Es dient der fachlichen Vorbereitung auf das Modul Embedded Systems sowie der praktischen Nachbereitung der bereits behandelten C/C++-Grundlagen.
\newline
Anhand eines kompakten Beispielprojekts mit Unit-Tests auf Host und Target soll ein gezielter Einblick in zentrale Aspekte im Embedded-Bereich vermittelt werden.
Dafür ist eine Strukturierung der Software, insbesondere im Hinblick auf die Trennung von Applikation, Treiber und Hardwareabstraktion notwendig.
Ergänzend wird das Verständnis zur Buildumgebung, zur eingesetzten Toolchain und zum Umgang mit Frameworks geschult.
Zusätzlich werden grundlegende Arbeitsweisen mit Visual Studio Code und dem Versionsverwaltungstool Git vermittelt und angewendet.
Die Inbetriebnahme eines Mikrocontrollers und die Kommunikation über eine serielle Schnittstelle runden die technische Umsetzung ab.

\subsection{Anforderungen und Rahmenbedingungen}
Technisch basiert die Umsetzung auf einem Mikrocontroller-Board (z.B. STM32-Nucleo), das über GPIOs, Timer und UART-Schnittstellen verfügt.
Die Softwareentwicklung erfolgt in C/C++ unter Verwendung von PlatformIO und CMake als Build-System.
Für die Kommunikation mit dem Target kommt HTerm zum Einsatz.
Die Testumgebung umfasst sowohl Host-basierte Unit-Tests mit Google Test als auch Target-nahe Tests mit einem  Framework namens wogtest,
das Google-Test-Kommandos interpretiert, aber speziell für ressourcenarme Systeme konzipiert ist.
\newline
Organisatorisch ist das Projekt auf eine Dauer von wenigen Wochen ausgelegt und wird als Einzelprojekt durchgeführt.
Die Dokumentation erfolgt parallel zur Entwicklung und umfasst sowohl technische Details als auch eine Bedienungsanleitung und eine Testübersicht.

\newpage
\subsubsection{Aufgabenstellung}
\textbf{Google-Test Interface für HAL-Tests auf dem Target}
\newline
Google-Test ist ein etabliertes Tool für Unit-Tests und hat sich in vielen Bereichen der C++-Software-Entwicklung verbreitet.
Im Embedded Bereich können damit die oberen Abstraktionsschichten einer Software getestet werden.
Google-Test ist ein großes Framework und deshalb nicht (oder nur bedingt) geeignet auf den begrenzten Ressourcen eines Micro-Controllers zu laufen.
Unit-Tests der HAL (Hardware Abstraction Layer) sind deshalb selten möglich.
Die Fa. MicroConsult, bekannt durch Trainings für die Software-Entwicklung, bietet eine Lösung an.
Diese nennt sich 'wogtest' (Without Googletest).
Es bietet eine leichtgewichtige Lösung, die Google-Test-Befehle versteht.
Dabei wird nur ein include benötigt.
Die zugehörige Implementierung muss für die jeweilige Zielplattform erstellt werden.
Wogtest ist frei und kostenlos samt Doku im Download von Microconsult erhältlich.
\newline\newline
\textbf{Die Herausforderung}
\newline
Verschiedene Aspekte der Software-Entwicklung werden berührt und vertieft.
Dazu gehören neben dem eigentlichen Test-Projekt auch Bereiche, die den Projektaufbau und die Build-Umgebung, sowie die Toolchain betreffen.
\newline

\textbf{Aufgaben}
\begin{enumerate}
  \item Vorhandenes Google-Test-Template in Betrieb nehmen unter Linux (wsl)
  \item Anlegen eines (lokalen) Git-Repositories
  \item Inbetriebnahme eines Micro-Controller-Boards (z.B. STM-Nucleo) mit einer kleinen Beispielapplikation (Blinky). Debugging, Flashen, …
  \item Implementierung der Funktionen aus dem 'wogtest'-include-File
  \item Aufbau eines Test-Templates für eine HAL-Komponente mit vorgegebenem Micro-Controller
  \item Stubbing und Mocking in Tests
  \item Erstellen einer Ausgabe-Schnittstelle für die Testergebnisse, z.B. über Segger RTT
  \item Erzeugen eines Test-Reports
  \item Erstellung der Dokumentation inklusive Anleitung im Markup-Format
  \item Optional: Umbau der Build-Umgebung zu einem Docker-Container\newline
\end{enumerate}
\textbf{Voraussetzung}
\newline
Grundkenntnisse in und Spaß an der hardwarenahen Software-Entwicklung.

%____________
\newpage
%==================================================================
\subsubsection{aus der Aufgabenstellung abgeleiteter Projektablauf}
\begin{itemize}
  \item Vorhandene Testumgebung in Betrieb nehmen
  \item Microcontroller in Betrieb nehmen (PlatformIO)
  \item Einarbeitung in Git / Projekt in Git-Repositories anlegen
  \item Einarbeitung in Buildumgebung CMake
  \item Beispielprogramm (led-blink) / Taster einbinden / Architektur mit Application, Treiber und Hardwareschicht
  \item Einarbeitung in Buildumgebung PlatformIO -> mehrere Build-Projekte
  \item Google Test auf Host (inclusive Stubbing) / CMakeList erstellen
  \item Hterm in Betrieb nehmen (Von Hterm an Controller senden und wieder zurück)
  \item per printf an Hterm senden (printf umleiten)
  \item Test für Target schreiben (wogtest) und auf Hterm ausgeben
  \item Doku inclusive UML-Klassendiagramm erstellen
\end{itemize}



\newpage
%==================================================================

\section{Planung}
Bei der Planung spielten vor allem Überlegungen zur Strukturierung des Beispielprojekts, für welches beispielhaft Unit-Tests geschrieben werden sollen, eine Rolle.
\subsection{Systemarchitektur}
Bei der Planung der Systemarchitektur geht es darum, die grundlegende Struktur in Software und das Zusammenspiel aller Komponenten des Systems frühzeitig und durchdacht festzulegen.
Das Ziel ist, eine klare, wartbare und erweiterbare Architektur zu schaffen, die sowohl funktionale Anforderungen als auch technische Rahmenbedingungen berücksichtigt.
Dafür sollte jede Komponente eine klar definierte Aufgabe haben.
Beispielsweise übernimmt die HAL ausschließlich hardwarenahe Funktionen, während die Applikation die Logik steuert.
Die Software wird hierfür in Applikation, Treiber und Hardwareabstraktionlayer (HAL) unterteilt. Diese Trennung fördert Wiederverwendbarkeit und Testbarkeit.
Die Architektur sollte so gestaltet sein, dass Unit-Tests auf Host und Target möglich sind.



\subsubsection{UML-Klassendiagramm}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{LED_Blink_UML.png}
  \caption{UMLKlassendiagramm}
  \label{fig:uml_led_blink}
\end{figure}
\subsubsection{Layer-Modell}

\newpage
%==================================================================

\section{Projekt}
\subsection{Code}
\subsubsection{Builds}
die Builds entwickelten sich im Laufe des
\


\newpage
%==================================================================

\section{Testkonzept}
\subsection{Teststrategie (Host/Target)}
\subsection{Mocking/Stubbing}
\subsection{Wogtest-Integration}
\subsection{Testausgabe}

\newpage
%==================================================================

\section{Bedienungsanleitung}
\subsection{Beispielapplikation}
\subsection{hier LaTeX testen}
\begin{verbatim}

    if(ButtonPressed)
    {
        ledState = ! ledState;
    }

\end{verbatim}

Your Abstractö qwfq wbo9qbvf9 quzwvauvbza ibzuvbEFH UZBoac BZBuzbviu eb vububIUBVDubbvvd Bb bdcub I UBCu bUB UBVI bvuz ubdvsdzbvVUZBVDB BU B b  biSDBVZUIB VuzsbdviszudaizsudhI D IUZBi


\textbf{Das ist fett.}
\textit{Das ist kursiv.}
\textbf{\textit{Fett und kursiv!}}

\subsection{}
\newpage
%==================================================================

\section{Anhang}
\subsection{Code}
\subsubsection{Klassen}

\end{document}